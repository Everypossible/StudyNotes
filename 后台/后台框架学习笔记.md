# SpringMVC

### 1、简介

1. 用处：
   1. SpringMVC和Spring
      1. Spring解决的是service、dao
      2. SpringMVC解决的是servlet
      3. SpringMVC是基于Spring的，是Spring的一个模块，做web开发使用的。SpringMVC也叫作Spring web MVC，说明他是Spring的核心技术，内部使用MVC架构模式
      4. SpringMVC是一个容器，管理界面层中的控制器对象，使用IOC核心技术
   2. ![image-20210718153443963](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210718153443963.png)
   3. SpringMVC底层是Servlet。以Servlet为核心，接受请求，处理请求。显示处理请求结果给用户。
   
2. SpringMVC中的核心Servlet--------DispatcherServlet
   1. DispatcherServlet 负责接收请求，响应处理结果
   2. 父类是HttpServlet
   3. 也叫作前端控制器(front controller)
   
3. SpringMVC是管理控制器对象，原来没有SpringMVC之前使用Servlet作为控制器对象使用。现在通过SpringMVC容器**创建一种叫做控制器的对象**。代替Servlet行使控制器的角色和功能。

4. 优点：
    1. 基于**MVC设计理念**的优秀的Web层框架。
    2. **通过一套MVC注解**，让POJO成为处理请求的控制器，而无需实现任何接口。
    3. 采用了**松散耦合可插拔结构**，比其他MVC框架更具有拓展性和灵活性。
    4. 支持RESTful编程风格的代码。
    
5. 什么是MVC

    <img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210821111221145.png" alt="image-20210821111221145" style="zoom:80%;" />

    

------



### 2、第一个SpringMVC程序

1. 主要通过注解的方式，创建控制器对象，处理请求

2. 需求：用户提交一个请求，服务端处理器在接收到这个请求后，给出一条欢迎信息，在响应界面显示该信息。
   1. ![image-20210718163551150](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210718163551150.png)
   
3. 步骤总结：
    1. 加入jar包
    
    2. 在 web.xml 中配置 DispatcherServlet
    
        ```xml
        <!--配置springMVC的前端控制器-->
            <servlet>
                <servlet-name>DispatcherServlet</servlet-name>
                <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
                <init-param>
                    <param-name>contextConfigLocation</param-name>
                    <param-value>classpath:spring-mvc.xml</param-value>
                </init-param>
                <load-on-startup>1</load-on-startup>
            </servlet>
            <servlet-mapping>
                <servlet-name>DispatcherServlet</servlet-name>
                <url-pattern>/</url-pattern>
            </servlet-mapping>
        ```
    
        
    
    3. 创建Controller类和视图页面
    
        ```java
        //@Controller---将该类放入Spring容器当中
        @Controller
        public class UserController {
        
            @RequestMapping("/quickstart")
            public String save() {
                System.out.println("Controller save running...");
                return "success.jsp";
            }
        }
        ```
    
        
    
    4. 使用注解配置Controller类中业务方法的映射地址
    
        ```java
        @RequestMapping("/quickstart")
        ```
    
        
    
    5. 配置Spring MVC的配置文件spring-mvc.xml
    
        ```xml
        <?xml version="1.0" encoding="UTF-8"?>
        <beans xmlns="http://www.springframework.org/schema/beans"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xmlns:context="http://www.springframework.org/schema/context"
               xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                                    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
        
        <!--Controller的组件扫描-->
            <context:component-scan base-package="com.crs.controller"/>
        </beans>
        ```
    
        
    
    6. 客户端发起请求测试
    
    
    
4. ![image-20210804082252691](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210804082252691.png)



------



### 3、SpringMVC的执行流程



#### 1、图解执行流程

（根据序号分辨执行顺序）

![image-20210804101758764](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210804101758764.png)

------



### 4、注解式开发

#### 1、@RequestMapping

![image-20210804102639970](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210804102639970.png)

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210821153109358.png" alt="image-20210821153109358" style="zoom:80%;" />



属性 value：请求的url地址。

位置： 1） 在方法的上面， 必须的。 2）在类的上面作为模块地址

```java
@RequestMapping(value ="/some.do")
public ModelAndView doSome(){
```



属性method：请求的方式， 使用RequestMehtod类的枚举，表示请求方式（不写则不限制）

```java
@RequestMapping(value ="/other.do",method = RequestMethod.POST)
public ModelAndView doOther(){
```

![](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210719164747106.png)

- get方式有缓存，一般用于查询谁查结果都一样的数据，有缓存效率较高
- post方式使用较多，安全
- 也就是说，只要指定了处理器方法匹配的请求提交方式为POST，则相当于指定了请求发送的方式：要么使用表单请求，要么使用AJAX请求。其它请求方式被禁用。





#### 2、接收请求中的参数

- 对应HttpServletRequest, HttpServletResponse, HttpSession 只需要在控制器方法的形参列表中，定义就可以了。框架会给参数赋值， 在控制器方法内部可以直接使用 request，response，session参数。

- 400 ： http status , 表示客户端异常。 主要是发生在用户提交参数过程中。

- 接收参数的问题

  - 参数最好使用包装类型。 例如Integer ，能接收空值情况， 接收的是null
  - 框架可以使用String到int ，long， float， double等类型转换。
  - post请求中有乱码的问题， 使用字符集过滤器。

- 接收请求中的参数： 逐个接收， 对象接收

  - 逐个接收： 请求中的参数名和控制器方法的形参名一样。按照名称对象接收参数

    ```xml
    <p>逐个接收请求参数</p>
    <form action="receive-property.do" method="post">
        姓名：<input type="text" name="name"> <br/>
        年龄：<input type="text" name="age"> <br/>
        <input type="submit" value="提交参数">
    </form>
    ```

    参数接收：
    	1、框架使用request对象，接收参数

    ​		 String name = request.getParameter("name");

     		String age = request.getParameter("age");

    ​	2、在中央调度器的内部调用 doProperParam 方法时，按名称对象传递参数

    ​			doPropertyParam(String name, Integer age)

    

    Controller接收参数

    ```java
    @RequestMapping(value ="/receive-property.do")
    public ModelAndView doPropertyParam(String name, Integer age) {} 
    ```
  



- get方式默认编码方式为UTF8，post不是（post要用过滤器解决中文乱码问题）

  - 在web.xml文件中使用SpringMVC框架提供的过滤器设置

    ```xml
    <!--    声明过滤器（框架提供的），解决post请求中文乱码问题-->
        <filter>
            <filter-name>CharacterEncodingFilter</filter-name>
            <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <!--        给过滤器属性赋值-->
            <init-param>
    <!--            项目使用的字符编码-->
                <param-name>encoding</param-name>
                <param-value>utf-8</param-value>
            </init-param>
            <init-param>
    <!--            强制请求对象（request）使用上面定义的编码格式-->
                <param-name>forceRequestEncoding</param-name>
                <param-value>true</param-value>
            </init-param>
            <init-param>
    <!--            强制应答对象（response）使用上面定义的编码格式-->
                <param-name>forceResponseEncoding</param-name>
                <param-value>true</param-value>
            </init-param>
        </filter>
        <filter-mapping>
            <filter-name>CharacterEncodingFilter</filter-name>
    <!--        /*表示强制所有请求先经过此过滤器-->
            <url-pattern>/*</url-pattern>
        </filter-mapping>
    ```

    

- @RequestParam：解决参数名和形参名不一样的问题

  属性：value ： 请求中的参数名称

    		required  ：boolean类型，默认是true

  ​							true：请求中必须有参数

  ​							false：请求中可以没有此参数

  位置：形参定义前



- 对象接收（参数多时更方便）

  在控制器方法的形参是java对象，使用java对象的属性接收请求中的参数

  要求：java对象的属性名必须和请求中的参数名一样
  
  



- 处理器方法的返回值

  - 返回ModelAndView

    - 请求的结果有数据和视图，用ModelAndView最方便

      数据：存放request作用域

      视图：执行forward转发操作

  - 返回String

    - 请求的结果只有视图

      返回值是String，执行的是forward转发操作

      返回的视图可以表示为完整视图路径（不能使用视图解析器），或者视图的逻辑名称（需要视图解析器）

  - 返回void

    - 没有数据和视图，可以使用HttpServletResponse对象输出数据，响应ajax请求

  - 返回对象Object

    - 返回的Object表示数据，还是视图。所以控制器方法返回对象Object，用来响应ajax请求。

    - 返回对象Object，可以是List，Student，Map，String。。。这些都是数据，而Ajax请求需要的就是数据。在Ajax请求中，一般需要从服务器返回的是JSON格式的数据，所以需要经常处理Java对象到JSON的转换，而且还需要输出数据响应ajax请求。框架提供了Java对象到JSON的转换和数据输出工作。

    - ```java
      //把对象转换为JSON
      ObjectMapper om = new ObjectMapper();
      String json = om.writeValueAsString(student);
      //输出JSON，响应ajax请求
      reponse.setContentType();
      PrintWritter pw = response.getWriter("application/json;charset=");
      pw.println(json);
      pw.flush();
      pw.close();
      ```

  - 框架提供了HttpMessageConverter（消息转换器）接口能接收数据
  
    1. 接收数据并把这些数据转换为java对象，给你的Controller使用
  
    2. 控制器方法返回对象，把对象转换为json，或其他数据（xml、text等）格式
  
    3. 该接口内的方法：
  
       - ```java
         /**
         	作用：检查var1这个类型的对象，能否转为MediaType表示的数据格式
         		如果能转为MediaType表示的类型，则返回true，调用read()
         */
         boolean canRead(Class<?> var1, @Nullable MediaType var2)
         ```
  
       - ```java
         /**
         	作用：检查var1这种数据类型能否转换为MediaType表示的数据格式
         */
         boolean canWrite(Class<?> var1, @Nullable MediaType var2)
         ```
  
       - ```java
         /**
         	作用：接收请求的数据，把数据转换为 var1 表示的对象
         */
         T read(Class<? extends T> var1, HttpInputMessage var2)
         ```
  
       - ```java
         /**
         	作用：把var1对象，按照var2说明的格式，把对象转换为json或者xml
         */
         void write(T var1, @Nullable MediaType var2, HttpOutputMessage var3)
         ```
  
   - MediaType：媒体类型，表示互联网中数据的格式。如：application/json，text/html，image/gif
  
   - 该接口常用的实现类
  
      ```java
         MappingJackson2HttpMessageConverter	//用Jackson工具库的ObjectMapper把java对象转换为JSON数据格式
         StringHttpMessageConverter	//把字符串类型数据，进行格式转换和编码
      ```
  
  - ![image-20210720152547374](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210720152547374.png)
  





#### 3、SpringMVC支持 ant风格 的路径

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210821154040672.png" alt="image-20210821154040672" style="zoom:80%;" />



#### 4、SpringMVC支持 路径中的占位符

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210821155021691.png" alt="image-20210821155021691" style="zoom:80%;" />

若使用占位符，则请求地址必须要有占位符的值，否则报404

 



------



### 5、SpringMVC的组件

![image-20210804105336265](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210804105336265.png)



------



### 6、SpringMVC的数据响应



#### 1、响应方式



##### 1、页面跳转

1. 直接返回字符串

    1. 注意区分转发和重定向的实现代码。

    2. 图解

        ![image-20210804110924299](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210804110924299.png)

        

2. 通过ModelAndView对象返回

    1. Controller的代码

        1. 创建ModelAndView对象方式1：（new出对象）

            ```java
            @RequestMapping("/quick2")
                public ModelAndView save2() {
                    ModelAndView modelAndView = new ModelAndView();
                    /**
                     * model: 作用：封装数据
                     * view：作用：展示视图
                     */
                    //设置视图数据
                    modelAndView.addObject("userName","itheima");
                    //设置视图名称
                    modelAndView.setViewName("success");
                    return modelAndView;
                }
            ```

        2. 创建ModelAndView对象方式2：（形参形式，有SpringMVC自己注入对象）

            ```java
            @RequestMapping("/quick3")
                public ModelAndView save3(ModelAndView modelAndView) {
                    /**
                     * model: 作用：封装数据
                     * view：作用：展示视图
                     */
                    //设置视图数据
                    modelAndView.addObject("userName","itheima");
                    //设置视图名称
                    modelAndView.setViewName("success");
                    return modelAndView;
                }
            ```

        3. 创建ModelAndView对象方式3：（Model和View分开）

            ```java
            @RequestMapping(value="/quick4")
                public String save4(Model model) {
                    model.addAttribute("userName","博学谷");
                    return "success";
                }
            ```

            

        

    2. 视图页面中获取视图数据

        ```jsp
        <!--用${属性名}获取数据-->
        ${userName}
        ```

        

    

##### 2、回写数据

1. 直接返回字符串

    1. Web基础阶段，客户端访问服务器，如果想直接回写字符串作为响应体返回的话，只需要使用response.getWriter().print("Hello world")即可，那么在SpringMVC中又怎么实现呢？

    2. 方法一：通过SpringMVC注入response对象实现

        1. 注意：返回值为void（因为是数据回写，不需要返回视图）

        2. ```java
            @RequestMapping(value="/quick5")
                public void save5(HttpServletResponse httpServletResponse) throws IOException {
                    httpServletResponse.getWriter().print("酷丁鱼");
                }
            ```

    3. 方式二：使用**<u>@ResponseBody</u>**注解告知SpringMVC框架 return字符串 返回的字符串不是跳转而是直接在http响应体中返回。

        ```java
        @RequestMapping(value="/quick6")
            @ResponseBody
            public String save7() throws IOException {
                return "酷丁鱼";
            }
        ```

    4. 方式三：使用JSON工具将对象转换成JSON格式字符串再返回

        ```java
        @RequestMapping(value="/quick8")
            @ResponseBody
            public String save8() throws IOException {
                User user = new User;
                user.setUserName("Mike");
                user.setAge(30);
                //使用JSON的转换工具将对象转换为JSON格式的字符串再返回
                ObjectMapper objectMapper = new ObjectMapper();
                String json = objectMapper.writeValueAsString(user);
                return json;
            }
        ```

        

2. 返回对象或集合

    1. 方式一：使用@ResponseBody

        1. 在spring-mvc.xml文件中配置处理器适配器（可用mvc的注解驱动替代这个繁琐的方案）

            ```java
            <bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
                    <property name="messageConverters">
                        <list>
                            <bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"/>
                        </list>
                    </property>
                </bean>
            ```

            

        2. 编写Java代码（返回的是User对象，再由视图处理器将其转为JSON格式字符串）

            ```java
             @RequestMapping(value="/quick9")
                @ResponseBody
                public User save9() throws IOException {
                    User user = new User;
                    user.setUserName("Mike");
                    user.setAge(30);
                    return user;
                }
            ```

            

        

    2. 使用mvc的注解驱动

        1. ![image-20210804145532315](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210804145532315.png)

        2. 代码实现步骤：

            1. 在spring-mvc.xml中配置&lt;mvc:annotation-driven/&gt;

                ```xml
                <!--    mvc的注解驱动-->
                    <mvc:annotation-driven/>
                ```

                



------



### 7、SpringMVC的获取请求数据

#### 1、请求参数类型

1. 客户端请求参数的格式是：name=value&name=value... ...
2. 服务器端获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收以下类型的参数：
    1. 基本类型参数
    2. POJO类型参数
    3. 数组类型参数
    4. 集合类型参数



#### 2、获得基本类型参数

- Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。

    如：![image-20210804173407286](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210804173407286.png)

    ```java
    @RequestMapping(value="/quick9")
        @ResponseBody
        public void quickMethod9(String username, int age) throws IOException {
            System.out.println(username);
            System.out.println(age);
        }
    ```

    

#### 3、获得POJO类型参数

- Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配。

    如：![image-20210804173407286](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210804173407286.png)

    ```java
    public class User {
    	private String username;
        private int age;
        getter/setter...
    }
    ```

    ```java
    @RequestMapping(value="/quick10")
    @ResponseBody
    public void quickMethod10(User user) throws IOException {
        System.out.println(user);
    }
    ```

    

#### 4、获得数组类型参数

- Controller中的业务方法的数组名称与请求参数的name一致，参数值会自动映射匹配。

    如：![image-20210804175231545](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210804175231545.png)

    ```java
    @RequestMapping(value="/quick11")
    @ResponseBody
    public void quickMethod11(String[] strs) throws IOException {
        System.out.println(Arrays.asList(strs));
    }
    ```

    

#### 5、获得集合类型参数

- 方法一：获得集合参数时，要将集合参数包装到一个POJO中才可以。

- 方法二：当使用ajax提交时，可以指定contentType为JSON形式，那么在方法参数位置使用@**Request**Body可以直接收集集合数据而无需使用POJO进行包装。、

    代码示例：

    ```jsp
    $,ajax({
    	type:"POST",
    	url:"",
    	data:JSON.stringify(userList),
    	contentType:"application/json;charset=utf-8"
    });
    ```

    ```java
    @RequestMapping(value="/quick12")
    @ResponseBody
    public void quickMethod12(@RequestBody List<User> userList) throws IOException {
        System.out.println(userList);
    }
    ```



#### 6、请求数据时常见的报错

- 静态资源访问的开启

    ```xml
    <!--静态资源访问的开启-->
    <mvc:resources mapping="/js/*" location="/js/"/>
    <mvc:resources mapping="/images/*" location="/images/"/>
    
    <!--也可以使用默认容器（Tomcat）-->
    <mvc:default-servlet-handler/>
    ```

    

- 请求数据乱码问题（主要是Post请求遇到）

    - 解决方案：在web.xml中设置一个过滤器进行编码的过滤

        ```xml
        <!--配置一个全局的过滤器-->
            <filter>
                <filter-name>CharacterEncodingFilter</filter-name>
                <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
                <init-param>
                    <param-name>encoding</param-name>
                    <param-value>UTF-8</param-value>
                </init-param>
            </filter>
            <filter-mapping>
                <filter-name>CharacterEncodingFilter</filter-name>
                <url-pattern>/*</url-pattern>
            </filter-mapping>
        ```



#### 7、参数绑定注解---@RequestParam

- 作用：当请求的参数与Controller的业务方法中的参数名称不一样时，就通过@RequestParam注解显示地绑定。

- 代码演示：将jsp中提交的name的值赋值给后台的username参数

    ```jsp
    <form action="" method="post">
        <input type="text" name="name"><br>
        <input type="submit" value="提交"><br>
    </form>
    ```

    ```java
    @RequestMapping(value="/quick13")
    @ResponseBody
    public void quickMethod13(@RequestParam(value="name") String username) throws IOException {
        System.out.println(username);
    }
    ```

- @RequestParam有如下参数可以使用：

    - value-----------绑定请求参数名称

    - required--------旨在指定请求参数是否必须包括，默认是true，提交时如果没有此参数则报错

    - defaultValue---当没有指定请求参数时，则使用指定的默认赋值

    - 代码演示：

        ```java
        @RequestMapping(value="/quick14")
        @ResponseBody
        public void quickMethod14(@RequestParam(value="name", required=false, defaultValue="itheima") String username) throws IOException {
            System.out.println(username);
        }
        ```

- <img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210822120429273.png" alt="image-20210822120429273" style="zoom:80%;" />
- 


#### 8、获得Restful风格的参数

- Restful风格：

    ![image-20210805095129296](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210805095129296.png)

    

- 获得Restful风格的参数：

    ![image-20210805095326378](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210805095326378.png)

    

    

#### 9、自定义类型转换器

- SpringMVC默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成int型进行参数设置。

- 但是不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器。例如：**<u>日期类型</u>**的数据就需要自定义转换器。

- 自定义类型转换器开发步骤：

    1. 定义转换器实现Converter接口

    2. 在配置文件中声明转换器

    3. 在 <annotation-driven> 中引用转换器

        代码演示：

        1. 自定义转换器类

            ```java
            public class DateConverter implements Converter<String, Date> {
            //前一个泛型参数String表示转换前的格式，后一个参数Date表示要转换成的类型
                @Override
                public Date convert(String s) {
                    //将日期字符串转换为日期对象，并返回
                    SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
                    Date date = null;
                    try {
                        date = format.parse(s);
                    } catch (ParseException e) {
                        e.printStackTrace();
                    }
                    return date;
                }
            }
            ```

            

        2. 在spring-mvc.xml文件中声明转换器类

            ```xml
            <!--声明转换器-->
            <bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean">
                <property name="converters">
                    <list>
                        <bean class="com.itheima.converter.DateConverter"></bean>
                    </list>
                </property>
            </bean>
            ```

            

        3. 在 <annotation-driven> 中引用转换器

            ```xml
            <mvc:annotation-driven conversion-service="conversionService"/>
            ```

            

        4. 测试

            ```java
            @RequestMapping(value="/quick15")
            @ResponseBody
            public void quickMethod15(Date date) throws IOException {
                System.out.println(date);
            }
            ```

        

        

#### 10、获得Servlet的相关API

- SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，常用的对象如下：

    - HttpServletRequest

    - HttpServletReponse

    - HttpSession

        如何使用？代码示例：

        ```java
        @RequestMapping(value="/quick16")
        @ResponseBody
        public void quickMethod16(HttpServletRequest request, HttpServletResponse response, HttpSession session) throws IOException {
            System.out.println(request);
            System.out.println(response);
            System.out.println(session);
        }
        ```



#### 11、获得请求头信息

- 使用注解@RequestHeader

    使用@RequestHeader可以获得请求头信息，相当于Web阶段学习的request.getHeader(name)

    @RequestHeader注解的属性如下：

    - value：请求头名称
    - required：是否必须携带此请求头

    代码示例：

    ```java
    @RequestMapping(value="/quick17")
    @ResponseBody
    public void quickMethod17(@RequestHeader(value="User-Agent", required=false) String headerValue) throws IOException {
        System.out.println(headerValue);
    }
    ```

- @CookieValue

    使用@CookieValue可获得指定Cookie的值

    @CookieValue注解的属性如下：

    - value：指定cookie的名称
    - required：是否必须携带此cookie

    代码示例：

    ```java
    @RequestMapping(value="/quick18")
    @ResponseBody
    public void quickMethod18(@RequestHeader(value="JSESSIONID", required=false) String jsessionid) throws IOException {
        System.out.println(jsessionid);
    }
    ```



#### 12、文件上传

##### 1、客户端表单实现

1. 文件上传客户端三要素：

    1. type="file"
    2. 提交方式是post
    3. 表单的enctype属性是多部分表单形式，即enctype="multipart/form-data"

    代码实现：

    ```html
    <form action="" method="post" enctype="multipart/form-data">
        名称：<input type="text" name="name"><br>
        文件：<input type="file" name="file"><br>
        <input type="submit“ value="提交><br>
    </form>
    ```

    



### 8、web开发中配置文件的说明

1. web.xml	部署描述符文件，给服务器(Tomcat)

   作用：服务器在启动的时候，读取web.xml，根据文件中的声明创建各种对象，根据文件中的声明 知道 请求和servlet等对象的关系

   

2. 框架的配置文件，springmvc的配置文件
   作用：声明框架创建的项目中的各种对象，主要是创建Controller对象的配置文件的加载顺序和功能

   

3. 配置文件的加载顺序和功能

   1. tomcat服务器启动， 读取web.xml. 根据web.xml文件中的说明，创建对象。

      ```xml
      <servlet>
              <servlet-name>myweb</servlet-name>
              <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
              <!--自定义配置文件的位置-->
              <init-param>
                  <param-name>contextConfigLocation</param-name>
                  <param-value>classpath:springmvc.xml</param-value>
              </init-param>
              <!--
                 表示服务器tomcat创建对象的顺序， 是个整数值， 大于等于0.
                 数值越小，创建对象的时间越早。
              -->
              <load-on-startup>1</load-on-startup>
          </servlet>
      ```

      创建DispatcherServlet他的对象， 会执行init()方法。 在init()方法中会执行 springmvc容器对象创建

      WebApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:springmvc.xml")

      

   2. springmvc框架， new ClassPathXmlApplicationContext(）读取springmvc的配置文件。

      ```xml
       <context:component-scan base-package="com.bjpowernode.controller" />
      
          <!--声明视图解析器：帮助处理视图-->
          <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
              <!--前缀：指定视图文件的路径-->
              <property name="prefix" value="/WEB-INF/view/" />
              <!--后缀：视图文件的扩展名-->
              <property name="suffix" value=".jsp" />
          </bean>
      ```

      使用组件扫描器base-package="com.bjpowernode.controller" ，遍历controller包中的所有类，MyController类， 找到这个类中的@Controller， @RequestMapping注解， 就能创建MyContoller对象。

      知道some.do的请求是执行doSome()方法

      以上 1， 2. 都是项目启动的过程， 没有执行任何的用户请求。

      

   3. 用户发起请求some.do----DispatcherServlet

      DispatcherServlet里面有 WebApplicationContext 。  WebApplicationContext 里面有MyController对象。

      请求some.do ，DispatcherServlet 就知道是 MyController处理的。







### 9、域对象共享数据

request域 -- 一次请求内有效，session域 -- 浏览器未关闭有效，application域 -- 后台服务器未关闭前有效



#### 1、request域共享数据



##### 1、通过 ServletAPI 向request域对象共享数据

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210822170641981.png" alt="image-20210822170641981" style="zoom:80%;" />

 







#### 2、session域共享数据

#### 3、application域对象







### 10、注解 配置SpringMVC

使用 配置类 和 注解 代替web.xml和SpringMVC配置文件的功能

#### 1、创建初始化类，代替web.xml

​		在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerinitializer接口的类，如果找到的话就用它来配置Servlet容器。
​		 Spring提供了这个接口的实现，名为SpringServletContainerlnitializer，这个类反过来又会查找实现WebApplicationlnitializer的类并将配置的任务交给它们来完成。Spring3.2引|入了一个便利的WebApplicationlnitializer基础实现，名为AbstractAnnotationConfigDispatcherServletinitializer， 当我们的类扩展了AbstractAnnotationConfigDispatcherServletinitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。





# Spring5

## 概述

### 1、Spring是什么？

​	Spring是一个轻量级的开源的J2EE框架。（轻量：引入的jar包较少）

### 2、Spring用来干什么？

​	针对bean的生命周期进行管理。

​	Spring可以解决企业应用开发的复杂性。

### 3、组成部分

​	主要由7部分组成：

​		Spring Core、Spring AOP、Spring ORM、Spring DAO、Spring Context、Spring Web 和 Spring Web MVC

### 4、Spring特点

- 方便解耦（因为使用了IOC），简化开发
- AOP的支持
- 方便程序的测试（如：Spring对Junit4支持，可以通过注解方便地测试Spring程序）
- 方便集成各种优秀框架
- 方便进行事务操作
- 降低Java EE API（如：JDBC、远程调用等）的使用难度
- Spring的源码是经典的Java学习规范

## IOC容器

### 1、IOC是什么？

- IOC：控制反转，把**创建对象**的过程（new 类名()）和**对象间调用**的过程交给Spring进行管理。

- 使用IOC的目的：降低代码耦合度。

- 配置类的对象的创建

  ```java
  //配置文件xml中创建对象
  //id：给类起的别名；class：类名；使用bean标签
  <bean id="user" class="com.atguigu.spring5.User"></bean>
  ```

- 获取配置创建的对象

  ```java
  //1、加载Spring配置文件
  ApplicationContext context = new ClassPathXmlApplicationContext("bean.xml");
  //2、获取配置创建的对象
  context.getBean("user",User.class);
  ```

### 2、IOC底层原理

1. XML解析、工厂模式、反射

2. 画图解析IOC底层原理

   ![image-20210729102833181](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210729102833181.png)

3. IOC思想基于IOC容器完成，IOC容器底层就是对象工厂。

4. Spring提供IOC容器实现的两种方式（两个接口）：

   1. BeanFactory：

      1. IOC容器基本实现，是Spring内部使用的接口，不提供给开发人员使用。
      2. 加载配置文件时不会创建对象，在获取（使用）对象时才去创建对象。

   2. ApplicationContext：

      1. BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员使用。

      2. 加载配置文件时就会吧配置文件对象进行创建。（这样更好，因为在Web项目中，这样可以在Tomcat启动时就将创建对象这种耗时耗资源的工作做了）

      3. 主要实现类：

         1. ClassPathXmlApplicationContext

         2. FileSystemXmlApplicationContext

            ```java
            //1、加载Spring配置文件
            ApplicationContext context = new ClassPathXmlApplicationContext("bean.xml");
            /**
            ClassPathXmlApplicationContext("")	括号内写的是类路径
            FileSystemXmlApplicationContext("") 括号内写的是文件所在电脑的磁盘路径
            */
            ```

            

### 3、IOC接口（BeanFactory）

### 4、IOC操作Bean管理

#### 1、Bean管理值就是两个操作：

1. Spring**创建对象**

   ```java
   <bean id="user" class="com.atguigu.spring5.User"></bean>
   ```

   

2. Spring**注入属性**（即调用实体类的set方法给对象的某个属性赋值）

#### 2、Bean管理操作有两种实现方式：

##### 1、基于xml：

1. **对象创建**：

   1. 具体操作：在Spring配置文件中，使用bean标签，**标签里面添加对应属性**，就可以实现对象创建。
   2. 在bean标签里有很多属性，介绍下常用的属性：
      1. id：对象的唯一标识
      2. class：类的全路径（包.类名）
   3. 创建对象时，默认采用无参构造方法。

2.  **注入属性**：

   1. DI（Dependency Injection）：依赖注入，就是注入属性；是IOC的实现方式之一。

      1. 第一种注入方式：使用set方式进行注入

         具体操作步骤：

         1. 创建类，定义对应的属性和set方法。

         2. 在Spring配置文件配置对象创建，配置属性注入。

            在bean标签中**使用property标签完成属性注入**

            （property自动调用类里面的set方法，set方法的命名要符合规则）

            ```xml
            <bean id="book" class="com.atguigu.spring5.Book">
                <!--name是属性名，value是要向属性注入的值-->
                <property name="" value=""></property>
            </bean>
            ```

      2. 简化set方式注入---------p名称空间注入

         ​	具体操作步骤：

         1. 添加p名称空间在配置文件中：

            ```xml
            <beans xmlns:p="http://www.springframework.org/schema/p"></beans>
            ```

         2. 进行属性注入：

            ```xml
            <bean id="book" class="com.atguigu.spring5.Book" p:属性名="属性值" p:属性名="属性值"></bean>
            ```

            

      3. 第二种注入方式：使用有参构造，创建对象时进行注入。

         具体操作步骤：

         1. 创建类，定义对应的属性和有参构造方法。

         2. 在Spring配置文件中进行配置。

            在bean标签中**使用construtor-arg标签完成属性注入**

            ```xml
            <bean id="orders" class="com.atguigu.spring5.Book">
            	<!--name是属性名，value是要向属性注入的值-->
                <constructor-arg name="" value=""></constructor-arg>
                <!--index是属性在类中的顺序（从0开始），value是要向属性注入的值，不过name更常用-->
                <constructor-arg index="" value=""></constructor-arg>
            </bean>
            ```

      4. 特殊字面量

         1. 赋值为null值（使用null标签赋null值）

            ```xml
            <property name="address">
                <null/>
            </property>
            ```

         2. 属性值包含特殊符号（如想给address赋值[[南京]]）

            1. 第一种方法：使用转义字符

               如：>使用&gt代替

            2. 第二种方法：使用CDATA

               ```xml
               <property name="address">
                   <value><![CDATA[<<南京>>]]></value>
               </property>
               ```

      5. 注入属性------外部bean

      6. 注入属性------内部bean和级联bean

   

##### 2、基于注解：

###### 1、目的：

​		简化xml配置实现**创建对象，注入属性**。

###### 2、格式：

​		@注解名称（属性名称=属性值，属性名称=属性值）

###### 3、作用位置：

​		注解可作用在类上、方法上、属性上。

###### 4、创建对象  提供的注解：

1. @Component---------普适
2. @Service---------------业务逻辑层或service层
3. @Controller------------web层
4. @Repository----------dao层或持久层

上面4个注解功能是一样的，都可以用来创建bean实例，用在任何层效果是一样的，只是不同层用不同的标识更便于开发人员区分。

###### 5、创建对象的注解 使用步骤：

1. 引入Spring依赖

    ```xml
    <!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.3.8</version>
    </dependency>
    ```

2. 开启组件扫描

    ```xml
    <context:component-scan base-package="com.kuang.dao"></context:component-scan>
    
    <!--组件扫描细节配置-->
    <!--	示例1
    	use-default-filters="false"------表示不使用默认的filter,自己配置filter
    	context:include-filter------设置扫描哪些内容
    
    	type------要扫描的标识（annotation表示注解）
    	expression="org.springframework.stereotype.Controller"------只扫描有Controller注解的类
    -->
    <context:component-scan base-package="com.kuang.dao" use-default-filters="false">
        <context:include-filter type="annotation"
                                expression="org.springframework.stereotype.Controller"/>
    </context:component-scan>
    
    <!--	示例2
    	context:exclude-filter------设置不扫描哪些内容
    
    	type------不扫描的标识（annotation表示注解）
    	expression="org.springframework.stereotype.Controller"------不扫描有Controller注解的类
    -->
    <context:component-scan base-package="com.kuang.dao">
        <context:exclude-filter type="annotation"
                                expression="org.springframework.stereotype.Controller"/>
    </context:component-scan>
    ```

    base-package后面写包名，如要扫描多个包，可将多个包用逗号隔开，或者写这些包的上层目录。

3. 创建类，在类上添加注解

    ```java
    @Component(value = "userService")	//value 即 对象名 ; 等效于<bean id="userService" class="..."/>
    //value 可以不写，默认值是 类名称的首字母小写
    public class UserService {
        ......
    }
    ```

###### 6、注入属性 提供的注解：

1. @AutoWired------根据属性类型进行自动装配
2. @Qualifier---------根据属性名称进行注入，一般用于一个接口有对个实现类时（要和@AutoWired一起使用）
3. @Resource-------可以根据类型注入，也可以根据属性名称注入（不建议使用，这个注解是在javax包下的，而其他注解是在spring包下的，jdk11后已取消掉这个注解）

这三种都是对 **对象** 进行属性注入，并不能用于普通类型（普通类型用@Value，如：String等）

```java
@AutoWired		//按照类型自动装配
private UserDao userDao;

@AutoWired
@Qualifier(value="某个实现类的对象的名称")
private UserDao userDao;

@Resource	//按照类型自动装配
private UserDao userDao;

@Resource(name = "userDaoImpl")	//按照属性名称装配
private UserDao userDao;
```

###### 7、纯注解开发（即全部使用注解，舍弃xml配置文件）

​	步骤：

1. 创建配置类

    ```java
    @Configuratiion		//表明这是一个配置类，替代xml配置文件
    @ComponentScan(basePackages = {"com.kuang.dao"})
    public class SpringConfig {
        ...
    }
    ```

2. 加载配置类

    ```java
    ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
    ```

    



## AOP

### 1、AOP 是什么：

- AOP：面向切面（方面）编程，不修改源代码进行功能增强。

### 2、AOP 主要意图：

- 将**日志记录、性能统计、安全控制、事务处理、异常处理**等代码从业务逻辑代码中划分出来，通过对这些代码的分离，我们希望将它们独立到非指导业务逻辑的代码中，进而改变这些行为的时候不影响业务逻辑的代码。（不通过修改源代码方式，在已有的主干功能中添加新功能） 

- 图解：（举例：在已有的登录功能中，不修改已有的源代码，添加权限判断的功能）

    ![image-20210801151248094](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210801151248094.png)

### 3、AOP 底层原理：

- 使用 **动态代理** 实现

    有两种情况动态代理（代理：创建一个要被增强对象的代理对象，通过代理对象实现**功能拓展**）

    1. 有接口情况------使用JDK动态代理

        1. 图解 JDK动态代理（创建**接口实现类**的代理对象，增强类的方法）

            ![image-20210801154042711](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210801154042711.png)

        2. JDK动态代理实现

            1. 使用Proxy类（java.lang包里）里面的方法创建代理对象

                ![image-20210801165900528](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210801165900528.png)

                newProxyInstance方法有三个参数

                第一个：该类的加载器

                第二个：增强方法所在的类，这个类实现的**接口**，支持多个接口

                第三个：创建代理对象实现InvocationHandler接口，写增强的方法

            2. 编写JDK动态代理代码实现

                1. 创建接口，定义方法

                    ```java
                    public interface UserDao {
                        public int add(int a, int b);
                        public String update(int id);
                    }
                    ```

                2. 创建接口实现类，实现方法

                    ````java
                    public class UserDaoImpl implements UserDao {
                        @Override
                        public int add(int a, int b) {
                            return a + b;
                        }
                        @Override
                        public String update(int id) {
                            return id;
                        }
                    }
                    ````

                3. 使用Proxy类创建接口代理对象（Spring已经写好了，这是底层代码）

                    ```java
                    public class JDKProxy {
                        public static void main(String[] args) {
                            //创建接口实现类代理对象
                            Class[] interfaces = {UserDao.class};
                            UserDaoImpl userDao = new UserDaoImpl();
                            UserDao dao = (UserDao) Proxy.newProxyInstance(JDKProxy.class, interfaces, new UserDaoProxy(userDao));
                            int result = dao.add(1,2);
                            System.out.println("result" + result);
                        }
                    }
                    
                    class UserDaoProxy implements InvocationHandler {
                    
                        //创建的是谁的代理对象，就把谁传递过来
                        //最常用的传递方法：有参构造传递
                        private Object obj;
                        public UserDaoProxy(Object obj) {
                            this.obj = obj;
                        }
                    
                        //增强的功能逻辑代码
                        //invoke方法的三个参数，proxy---代理对象；method---执行的方法；args---传递的参数
                        @Override
                        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                            //被执行的方法之前
                            System.out.println("执行方法之前");
                            //被执行的方法执行
                            Object res = method.invoke(obj, args);
                            //被执行的方法之后
                            System.out.println("执行方法之后");
                            return res;
                        }
                    }
                    ```

                4. 放好久

                5.  阿发

    2. 没有接口的情况------使用CGLIB动态代理

        1. 图解 CGLIB动态代理（创建**子类**的代理对象，增强类的方法）

            ![image-20210801154338624](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210801154338624.png)

### 4、AOP 术语

1. 连接点：类里面哪些方法可以被增强，这些方法称为连接点。
2. 切入点：实际被真正增强的方法，称为切入点。
3. 通知（增强）：
    1. 实际增强的逻辑部分称为通知（增强）。
    2. 通知有5种类型：
        1. 前置通知
        2. 后置通知
        3. 环绕通知
        4. 异常通知
        5. 最终通知
4. 切面：是个动作，把通知应用到切入点的**过程**就叫做切面。



### 5、Spring实现AOP

#### 1、实现方式

​		Spring框架一般都是基于**AspectJ实现AOP 操作

#### 2、什么是AspectJ.

​		AspectJ不是Spring组成部分，是**独立的** AOP框架，但一般把AspectJ和 Spimg框架一起使用，进行AOP操作.

#### 3、实现方式

1. 基于xml配置文件实现
2. 基于注解方式实现（更常使用）

#### 4、操作步骤：

1. 在项目中引入AOP相关依赖（spring-aspects-5.2.6.RELEASE.jar等，具体再上网查“结合aspectJ和Spring需要的Maven依赖”）

2. 切入点表达式

    1. 目的：使程序知道要对哪个类中的哪个方法进行增强

    2. 语法结构：execution（【权限修饰符】【返回类型】【类的全路径】【方法名称】（【参数列表】））

        注意：权限修饰符不写则全类型都可；返回类型写 * 则全类型都可


​	

## JdbcTemplate

## 事务管理

## Spring5新特性





## Spring 源码分析

### 1、BeanDefinition

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820152344162.png" alt="image-20210820152344162" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820152426844.png" alt="image-20210820152426844" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820152811976.png" alt="image-20210820152811976" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820152850320.png" alt="image-20210820152850320" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820152906272.png" alt="image-20210820152906272" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820152918994.png" alt="image-20210820152918994" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820152928048.png" alt="image-20210820152928048" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820152936756.png" alt="image-20210820152936756" style="zoom:50%;" />





### 2、BeanFactory

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820153058966.png" alt="image-20210820153058966" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820153118233.png" alt="image-20210820153118233" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820153237549.png" alt="image-20210820153237549" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820153250279.png" alt="image-20210820153250279" style="zoom:50%;" />







### 3、Bean生命周期

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820153337989.png" alt="image-20210820153337989" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820153407447.png" alt="image-20210820153407447" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820153451017.png" alt="image-20210820153451017" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820153521794.png" alt="image-20210820153521794" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820153544490.png" alt="image-20210820153544490" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820153601788.png" alt="image-20210820153601788" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820153624981.png" alt="image-20210820153624981" style="zoom:50%;" />













### 4、@Autowired

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820153715528.png" alt="image-20210820153715528" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820155546776.png" alt="image-20210820155546776" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820155642620.png" alt="image-20210820155642620" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820155800551.png" alt="image-20210820155800551" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820155901621.png" alt="image-20210820155901621" style="zoom:50%;" />









### 5、@Resource

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820155945335.png" alt="image-20210820155945335" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820160017051.png" alt="image-20210820160017051" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820160049297.png" alt="image-20210820160049297" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820160114455.png" alt="image-20210820160114455" style="zoom:50%;" />







### 6、@Value

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820160224061.png" alt="image-20210820160224061" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820160259651.png" alt="image-20210820160259651" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820160330618.png" alt="image-20210820160330618" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820160417092.png" alt="image-20210820160417092" style="zoom:50%;" />









### 7、FactoryBean

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820160520067.png" alt="image-20210820160520067" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820160546818.png" alt="image-20210820160546818" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820160722960.png" alt="image-20210820160722960" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820160658872.png" alt="image-20210820160658872" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820160835522.png" alt="image-20210820160835522" style="zoom: 67%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820160910676.png" alt="image-20210820160910676" style="zoom:67%;" />













### 8、ApplicationContext

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820160957353.png" alt="image-20210820160957353" style="zoom:67%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820161058364.png" alt="image-20210820161058364" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820161131766.png" alt="image-20210820161131766" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820161206736.png" alt="image-20210820161206736" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820161243267.png" alt="image-20210820161243267" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820161358092.png" alt="image-20210820161358092" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820161421181.png" alt="image-20210820161421181" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820161438161.png" alt="image-20210820161438161" style="zoom:50%;" />









### 9、BeanPostProcessor

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820161525072.png" alt="image-20210820161525072" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820161549844.png" alt="image-20210820161549844" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820161621716.png" alt="image-20210820161621716" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820161655358.png" alt="image-20210820161655358" style="zoom:50%;" />





### 10、AOP

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820161741666.png" alt="image-20210820161741666" style="zoom:50%;" />

![image-20210820161807226](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820161807226.png)

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820161837659.png" alt="image-20210820161837659" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820161857538.png" alt="image-20210820161857538" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820161925375.png" alt="image-20210820161925375" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820161951965.png" alt="image-20210820161951965" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820162011318.png" alt="image-20210820162011318" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820162036856.png" alt="image-20210820162036856" style="zoom:50%;" />

<img src="C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210820162215102.png" alt="image-20210820162215102" style="zoom: 67%;" />







## 手写Spring

### 1、手写 Spring启动 以及 扫描流程

### 2、手写 getBean() 流程

### 3、手写 Bean生命周期 流程

### 4、手写 依赖注入 流程

### 5、手写 BeanPostProcessor机制

### 6、手写 AOP 机制



















# Mybatis

## 1、简介

### 1、原始的JDBC操作：

![image-20210802121435883](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210802121435883.png)

### 2、优化原始JDBC操作：

1. 原始jdbc开发存在的问题如下：
    1. 数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能
    2. sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。
    3. 查询操作时；需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置
2. 应对上述问题给出的解决方案：
    1. 使用数据库连接池初始化连接资源
    2. 将sql语句抽取到xml配置文件中
    3. 使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射

### 3、什么是Mybatis：

- mybatis是一个优秀的**基于java**的**持久层**框架，它内部封装了jdbc，**使开发者只需要关注sql语句本身**，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。
- mybatis通过**xml或注解**的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。
- 最后mybatis框架执行sql并**将结果映射为java对象并返回**。采用ORM思想（对象关系映射）解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。



## 2、快速入门

### 1、Mybatis开发步骤：

1. 添加Mybatis的坐标，即引入相关jar包

2. 创建user数据表

3. 编写User实体类

4. 编写映射配置文件UserMapper.xml（编写sql语句）

    ```xml
    <!--约束头-->
    <?xml version="1.0" encoding="UTF-8" ?>
    <!DOCTYPE mapper
            PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
            "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    <!--编写SQL语句-->
    <mapper namespace="userMapper">
        <select id="findAll" resultType="com.itheima.UserDao">
        	select * from user
        </select>
    
    </mapper>
    ```

5. 编写核心文件SqlMapConfig.xml（设置配置）

    ```xml
    <!--约束头-->
    <?xml version="1.0" encoding="UTF-8" ?>
    <!DOCTYPE configuration
            PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
            "http://mybatis.org/dtd/mybatis-3-config.dtd">
    <!--配置-->
    <configuration>
        <!--数据源环境-->
        <!--default是默认环境-->
        <environments default="development">
            <environment id="development">
                <!--事务管理器-->
                <transactionManager type="JDBC"></transactionManager>
                <!--数据源类型-->
                <dataSource type="POOLED">
                    <!--数据库配置信息-->
                    <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                    <property name="url" value="jdbc:mysql://localhost:3306/数据库名称?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMT%2B8"/>
                    <property name="username" value=""/>
                    <property name="password" value=""/>
                </dataSource>
            </environment>
        </environments>
        
        <!--配置文件要去加载映射文件-->
        <mappers>
            <mapper resource="com/itheima/mapper/UserMapper.xml"></mapper>
        </mappers>
    </configuration>
    ```

6. 编写测试类

    ```java
    public class MybatisTest {
        public void test() throws IOException {
            //加载核心配置文件
            InputStream resourceAsStream = Resources.getResourceAsStream("SqlMapConfig.xml");
            //获得sqlSession工厂对象
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
            //获得sqlSession对象
            SqlSession sqlSession = sqlSessionFactory.openSession();
            //执行SQL语句
            //selectList()的参数就是namespace.id
            List<User> userList = sqlSession.selectList("userMapper.findAll");
            //打印结果
            System.out.println(userList);
            //释放资源
            sqlSession.close();
        }
    }
    ```

    

## 3、映射文件概述

### 1、图解映射文件

​		![image-20210802164816490](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210802164816490.png)

## 4、增删改查操作

1. 在UserMapper.xml文件中写入sql

    ```xml
    <!--插入操作-->
    <insert id="save" parameterType="">
    	insert into user values(#{id}, #{username}, #{password})
    </insert>
    ```

2. 在插入操作测试类的执行完SQL语句后记得手动提交事务

    ```java
    sqlSession.insert("userMapper.save",user);
    //手动提交事务
    sqlSession.commit();
    ```

3. 插入操作注意事项

    ![image-20210802212239585](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210802212239585.png)

4. SQL文件

    ![image-20210802214618549](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210802214618549.png)

    



## 5、核心配置文件概述

![image-20210802215036209](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210802215036209.png)



### 1、configuration标签

​		根标签

### 2、environments标签

1. 图解标签意思

    ![image-20210802215305560](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210802215305560.png)

    

### 3、mappers标签

### 4、properties标签

### 5、typeAliases标签



## 6、相应API

















# SSM整合

## 1、整合策略

### 1、整合顺序

![image-20210806103056438](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210806103056438.png)

## 2、Mybatis整合Spring

### 1、整合目标

![image-20210806104349786](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210806104349786.png)



### 2、所需jar包

![image-20210806104454556](C:\Users\RS\AppData\Roaming\Typora\typora-user-images\image-20210806104454556.png)
